// Generated by CoffeeScript 1.9.3
(function() {
  angular.module('app').factory('PushPlugin', function($q, $http, $ionicPlatform, $window, $log, PluginUtils, Config) {
    var callbackCurRef, callbackList, cancel, onNotification, pluginName, pluginTest, register, sendPush, service, setApplicationIconBadgeNumber, showToastNotification;
    pluginName = 'Push';
    pluginTest = function() {
      return $window.plugins && $window.plugins.pushNotification;
    };
    callbackCurRef = 1;
    callbackList = {};
    service = {
      type: {
        ALL: 'all',
        MESSAGE: 'message',
        REGISTERED: 'registered',
        ERROR: 'error'
      },
      sendPush: sendPush,
      register: register,
      onNotification: onNotification,
      cancel: cancel
    };
    sendPush = function(recipients, data) {
      if ($ionicPlatform.is('android')) {
        return $http.post('https://android.googleapis.com/gcm/send', {
          registration_ids: recipients,
          data: data
        }, {
          headers: {
            Authorization: 'key=' + Config.gcm.apiServerKey
          }
        }).then(function() {
          return true;
        });
      } else {
        $window.alert('Your platform don\'t have push support :(');
        return $q.when(false);
      }
    };
    register = function(senderID) {
      return PluginUtils.onReady(pluginName, pluginTest).then(function() {
        var callbackRef, defer;
        defer = $q.defer();
        callbackRef = onNotification((function(notification) {
          defer.resolve(notification.regid);
          return cancel(callbackRef);
        }), service.type.REGISTERED);
        $window.plugins.pushNotification.register((function(data) {}), (function(err) {
          return registerDefer.reject(err);
        }), {
          senderID: senderID,
          ecb: 'onPushNotification'
        });
        return defer.promise;
      });
    };
    onNotification = function(callback, _type) {
      return PluginUtils.onReady(pluginName, pluginTest).then(function() {
        var id;
        id = callbackCurRef++;
        callbackList[id] = {
          fn: callback,
          type: _type || service.type.MESSAGE
        };
        return id;
      });
    };
    cancel = function(id) {
      return PluginUtils.onReady(pluginName, pluginTest).then(function() {
        return delete callbackList[id];
      });
    };
    setApplicationIconBadgeNumber = function(badgeNumber) {
      return PluginUtils.onReady(pluginName, pluginTest).then(function() {
        var defer;
        defer = $q.defer();
        $window.plugins.pushNotification.setApplicationIconBadgeNumber((function(a, b, c) {
          console.log('success a', a);
          console.log('success b', b);
          console.log('success c', c);
          return defer.resolve();
        }), (function(err) {
          return defer.reject(err);
        }), badgeNumber);
        return defer.promise;
      });
    };
    showToastNotification = function(options) {
      return PluginUtils.onReady(pluginName, pluginTest).then(function() {
        var defer;
        defer = $q.defer();
        $window.plugins.pushNotification.showToastNotification((function(a, b, c) {
          console.log('success a', a);
          console.log('success b', b);
          console.log('success c', c);
          return defer.resolve();
        }), (function(err) {
          return defer.reject(err);
        }), options);
        return defer.promise;
      });
    };
    $window.onPushNotification = function(notification) {
      var i, results;
      if (notification.event === service.type.MESSAGE) {

      } else if (notification.event === service.type.REGISTERED) {

      } else if (notification.event === service.type.ERROR) {
        $log.error('GCM error', notification);
      } else {
        $log.error('unknown GCM event has occurred', notification);
      }
      results = [];
      for (i in callbackList) {
        if (callbackList[i].type === service.type.ALL || callbackList[i].type === notification.event) {
          results.push(callbackList[i].fn(notification));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    return service;
  });


  /**************************
     *                        *
     *      Browser Mock      *
     *                        *
     *************************
   */

  ionic.Platform.ready(function() {
    if (!(ionic.Platform.isAndroid() || ionic.Platform.isIOS() || ionic.Platform.isIPad())) {
      if (!window.plugins) {
        window.plugins = {};
      }
      if (!window.plugins.pushNotification) {
        return window.plugins.pushNotification = (function() {
          return {
            register: function(successCallback, errorCallback, options) {
              setTimeout((function() {
                if (successCallback) {
                  successCallback('OK');
                }
                if (options && options.ecb) {
                  eval(options.ecb)({
                    event: 'registered',
                    regid: 'registration_id'
                  });
                }
              }), 0);
            },
            setApplicationIconBadgeNumber: function(successCallback, errorCallback, badge) {
              if (errorCallback) {
                errorCallback('Invalid action : setApplicationIconBadgeNumber');
              }
            },
            showToastNotification: function(successCallback, errorCallback, options) {
              if (errorCallback) {
                errorCallback('Invalid action : showToastNotification');
              }
            },
            unregister: function(successCallback, errorCallback, options) {},
            onDeviceReady: function(opts) {},
            registerDevice: function(successCallback, errorCallback) {
              if (successCallback) {
                successCallback('status');
              }
            }
          };
        })();
      }
    }
  });

}).call(this);

//# sourceMappingURL=push.js.map
