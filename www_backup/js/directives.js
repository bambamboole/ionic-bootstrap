// Generated by CoffeeScript 1.9.3
(function() {
  var blurOnKeyboardOut, debounce, focusOnKeyboardOpen, href;

  angular.module('app').directive('href', href).directive('debounce', debounce).directive('blurOnKeyboardOut', blurOnKeyboardOut).directive('focusOnKeyboardOpen', focusOnKeyboardOpen);

  href = function($window) {
    var externePrefixes, isExterneUrl;
    externePrefixes = void 0;
    isExterneUrl = void 0;
    externePrefixes = ['http:', 'https:', 'tel:', 'sms:'];
    isExterneUrl = function(url) {
      var i;
      i = void 0;
      if (url) {
        for (i in externePrefixes) {
          i = i;
          if (url.indexOf(externePrefixes[i]) === 0) {
            return true;
          }
        }
      }
      return false;
    };
    return {
      restrict: 'A',
      scope: {
        url: '@href'
      },
      link: function(scope, element, attrs) {
        if (isExterneUrl(scope.url)) {
          return element.bind('click', function(e) {
            e.preventDefault();
            return $window.open(encodeURI(scope.url), '_system', 'location=yes');
          });
        }
      }
    };
  };

  debounce = function($timeout) {
    return {
      restrict: 'A',
      require: 'ngModel',
      priority: 99,
      link: function(scope, element, attr, ngModelCtrl) {
        debounce = void 0;
        if (attr.type === 'radio' || attr.type === 'checkbox') {
          return;
        }
        debounce = void 0;
        element.unbind('input');
        element.bind('input', function() {
          $timeout.cancel(debounce);
          return debounce = $timeout((function() {
            return scope.$apply(function() {
              return ngModelCtrl.$setViewValue(element.val());
            });
          }), attr.ngDebounce || 1000);
        });
        return element.bind('blur', function() {
          return scope.$apply(function() {
            return ngModelCtrl.$setViewValue(element.val());
          });
        });
      }
    };
  };

  blurOnKeyboardOut = function($window) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        return $window.addEventListener('native.keyboardhide', function(e) {
          element[0].blur();
          return scope.safeApply(function() {
            return scope.$eval(attrs.blurOnKeyboardOut);
          });
        });
      }
    };
  };

  focusOnKeyboardOpen = function($window) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        var keyboardOpen;
        keyboardOpen = void 0;
        keyboardOpen = false;
        $window.addEventListener('native.keyboardshow', function(e) {
          keyboardOpen = true;
          return element[0].focus();
        });
        $window.addEventListener('native.keyboardhide', function(e) {
          keyboardOpen = false;
          return element[0].blur();
        });
        return element[0].addEventListener('blur', (function(e) {
          if (keyboardOpen) {
            return element[0].focus();
          }
        }), true);
      }
    };
  };

}).call(this);

//# sourceMappingURL=directives.c.js.map
