// Generated by CoffeeScript 1.9.3
(function() {
  angular.module('app').factory('CrudRestUtils', function($http, $q, $cacheFactory, $window, $log, CollectionUtils, Utils) {
    var _crudConfig, _crudFind, _crudFindOne, _crudGet, _crudGetAll, _crudGetUrl, _crudRemove, _crudSave, _ctrlAddElt, _ctrlCancelEdit, _ctrlCreate, _ctrlEdit, _ctrlEltRestUrl, _ctrlInit, _ctrlRemove, _ctrlRemoveElt, _ctrlSave, _ctrlSort, _ctrlToggle, _invalideAllCache, _setInCache, createCrud, createCrudCtrl, service;
    service = {
      createCrud: createCrud,
      createCrudCtrl: createCrudCtrl
    };

    /**
       * Create a service connected to a REST backend with following endpoints :
       *  - GET     /endpoint       : return an array of all values in the property 'data' of the response
       *  - GET     /endpoint?where : return an array of values matching object specified in 'where' in the property 'data' of the response
       *  - GET     /endpoint/:id   : return the value with the specified id in the property 'data' of the response
       *  - POST    /endpoint       : create new value with a random id an return the created id in the property 'data' of the response
       *  - PUT     /endpoint/:id   : update the value with the specified id
       *  - DELETE  /endpoint/:id   : delete the value with the specified id and return only the status code
       *
       * Params starting with '_' are optionnals
       * @param endpointUrl: String                     REST API url (like http://localhost:9000/api/v1/todos)
       * @param _objectKey: String (default: 'id')      elt attribute used as id (access to http://localhost:9000/api/v1/todos/myid as elt url !)
       * @param _getData: function(response){}          transform API response and returns data (list of elts or elt according to called methods)
       * @param _processBreforeSave: function(elt){}    process elt before saving it
       * @param _useCache: Boolean (default: true)      should the service use angular cache
       * @param _httpConfig: Headers                    http headers to add to all API requests
     */
    createCrud = function(endpointUrl, _objectKey, _getData, _processBreforeSave, _useCache, _httpConfig) {
      var CrudSrv, cache, objectKey;
      objectKey = _objectKey ? _objectKey : 'id';
      cache = _useCache === false ? null : $cacheFactory.get(endpointUrl) || $cacheFactory(endpointUrl);
      CrudSrv = {
        eltKey: objectKey,
        getUrl: function(_id) {
          return _crudGetUrl(endpointUrl, _id);
        },
        getAll: function(_noCache) {
          return _crudGetAll(endpointUrl, objectKey, cache, _noCache, _getData, _httpConfig);
        },
        find: function(where, params) {
          return _crudFind(where, params, endpointUrl, objectKey, cache, _getData, _httpConfig);
        },
        findOne: function(where) {
          return _crudFindOne(where, endpointUrl, objectKey, cache, _getData, _httpConfig);
        },
        get: function(id, _noCache) {
          return _crudGet(id, endpointUrl, objectKey, cache, _noCache, _getData, _httpConfig);
        },
        save: function(elt) {
          return _crudSave(elt, endpointUrl, objectKey, cache, _processBreforeSave, _getData, _httpConfig);
        },
        remove: function(elt) {
          return _crudRemove(elt, endpointUrl, objectKey, cache, _httpConfig);
        }
      };
      return CrudSrv;
    };

    /*
       * Create data and functions to use in crud controller, based on a CrudSrv
       *
       * Params starting with '_' are optionnals
       * @param CrudSrv                       data service to connect with
       * @param _defaultSort: {order, desc}   how to sort elts by default
       * @param _defaultFormElt: elt          default elt to load in form when create new elt
     */
    createCrudCtrl = function(CrudSrv, _defaultSort, _defaultFormElt) {
      var ctrl, data;
      data = {
        elts: [],
        currentSort: _defaultSort ? _defaultSort : {},
        selectedElt: null,
        defaultFormElt: _defaultFormElt ? _defaultFormElt : {},
        form: null,
        status: {
          error: null,
          loading: true,
          saving: false,
          removing: false
        }
      };
      ctrl = {
        data: data,
        fn: {
          sort: function(order, _desc) {
            return _ctrlSort(order, _desc, data);
          },
          toggle: function(elt) {
            return _ctrlToggle(elt, CrudSrv, data);
          },
          create: function() {
            return _ctrlCreate(data);
          },
          edit: function(elt) {
            return _ctrlEdit(elt, data);
          },
          addElt: function(obj, attr, _elt) {
            return _ctrlAddElt(obj, attr, _elt);
          },
          removeElt: function(arr, index) {
            return _ctrlRemoveElt(arr, index);
          },
          cancelEdit: function() {
            return _ctrlCancelEdit(data);
          },
          save: function(_elt) {
            return _ctrlSave(_elt, CrudSrv, data);
          },
          remove: function(elt) {
            return _ctrlRemove(elt, CrudSrv, data);
          },
          eltRestUrl: function(_elt) {
            return _ctrlEltRestUrl(_elt, CrudSrv);
          }
        }
      };
      _ctrlInit(CrudSrv, data, _defaultSort);
      return ctrl;
    };
    _crudGetUrl = function(endpointUrl, _id) {
      return endpointUrl + (_id ? '/' + _id : '');
    };
    _crudConfig = function(_cache, _httpConfig) {
      var cfg;
      cfg = _httpConfig ? angular.copy(_httpConfig) : {};
      if (_cache) {
        cfg.cache = _cache;
      }
      return cfg;
    };
    _setInCache = function(_cache, endpointUrl, objectKey, result, elt) {
      if (_cache) {
        return _cache.put(_crudGetUrl(endpointUrl, elt[objectKey]), [result.status, JSON.stringify(elt), result.headers(), result.statusText]);
      }
    };
    _invalideAllCache = function(_cache, endpointUrl) {
      if (_cache) {
        return _cache.remove(_crudGetUrl(endpointUrl));
      }
    };
    _crudGetAll = function(endpointUrl, objectKey, _cache, _noCache, _getData, _httpConfig) {
      var url;
      url = _crudGetUrl(endpointUrl);
      if (_cache && _noCache) {
        _cache.remove(url);
      }
      return $http.get(url, _crudConfig(_cache, _httpConfig)).then(function(result) {
        var elts, i;
        elts = typeof _getData === 'function' ? _getData(result) : result.data;
        if (Array.isArray(elts)) {
          if (_cache) {
            for (i in elts) {
              _setInCache(_cache, endpointUrl, objectKey, result, elts[i]);
            }
          }
          return elts;
        }
      });
    };
    _crudFind = function(where, params, endpointUrl, objectKey, _cache, _getData, _httpConfig) {
      var url;
      url = _crudGetUrl(endpointUrl);
      return $http.get(url + '?where=' + JSON.stringify(where) + (params ? params : ''), _crudConfig(null, _httpConfig)).then(function(result) {
        var elts, i;
        elts = typeof _getData === 'function' ? _getData(result) : result.data;
        if (Array.isArray(elts)) {
          if (_cache) {
            for (i in elts) {
              _setInCache(_cache, endpointUrl, objectKey, result, elts[i]);
            }
          }
          return elts;
        }
      });
    };
    _crudFindOne = function(where, endpointUrl, objectKey, _cache, _getData, _httpConfig) {
      return _crudFind(where, '', endpointUrl, objectKey, _cache, _getData, _httpConfig).then(function(elts) {
        if (Array.isArray(elts) && elts.length > 0) {
          if (elts.length > 1) {
            $log.warn('More than one result for clause', where);
          }
          return elts[0];
        }
      });
    };
    _crudGet = function(id, endpointUrl, objectKey, _cache, _noCache, _getData, _httpConfig) {
      var url;
      url = _crudGetUrl(endpointUrl, id);
      if (_cache && _noCache) {
        _cache.remove(url);
      }
      return $http.get(url, _crudConfig(_cache, _httpConfig)).then(function(result) {
        var elt;
        elt = typeof _getData === 'function' ? _getData(result) : result.data;
        if (elt && elt[objectKey]) {
          return elt;
        }
      });
    };
    _crudSave = function(elt, endpointUrl, objectKey, _cache, _processBreforeSave, _getData, _httpConfig) {
      var promise;
      if (elt) {
        if (typeof _processBreforeSave === 'function') {
          _processBreforeSave(elt);
        }
        promise = null;
        if (elt[objectKey]) {
          promise = $http.put(_crudGetUrl(endpointUrl, elt[objectKey]), elt, _crudConfig(null, _httpConfig));
        } else {
          promise = $http.post(_crudGetUrl(endpointUrl), elt, _crudConfig(null, _httpConfig));
        }
        return promise.then(function(result) {
          var data, newElt;
          data = typeof _getData === 'function' ? _getData(result) : result.data;
          newElt = angular.copy(elt);
          if (!newElt[objectKey] && data[objectKey]) {
            newElt[objectKey] = data[objectKey];
          }
          if (!newElt['createdAt'] && data['createdAt']) {
            newElt['createdAt'] = data['createdAt'];
          }
          _setInCache(_cache, endpointUrl, objectKey, result, newElt);
          _invalideAllCache(_cache, endpointUrl);
          return newElt;
        });
      } else {
        return $q.when();
      }
    };
    _crudRemove = function(elt, endpointUrl, objectKey, _cache, _httpConfig) {
      var url;
      if (elt && elt[objectKey]) {
        url = _crudGetUrl(endpointUrl, elt[objectKey]);
        return $http["delete"](url, _crudConfig(null, _httpConfig)).then(function(result) {
          if (_cache) {
            _cache.remove(url);
            return _invalideAllCache(_cache, endpointUrl);
          }
        });
      } else {
        return $q.when();
      }
    };
    _ctrlInit = function(CrudSrv, data, _defaultSort) {
      if (_defaultSort) {
        Utils.sort(data.elts, _defaultSort);
      }
      return CrudSrv.getAll().then((function(elts) {
        if (data.currentSort) {
          Utils.sort(elts, data.currentSort);
        }
        data.elts = elts;
        return data.status.loading = false;
      }), function(err) {
        $log.warn('can\'t load data', err);
        data.status.loading = false;
        return data.status.error = err.statusText ? err.statusText : 'Unable to load data :(';
      });
    };
    _ctrlSort = function(order, _desc, data) {
      if (data.currentSort.order === order) {
        data.currentSort.desc = !data.currentSort.desc;
      } else {
        data.currentSort = {
          order: order,
          desc: _desc ? _desc : false
        };
      }
      return Utils.sort(data.elts, data.currentSort);
    };
    _ctrlToggle = function(elt, CrudSrv, data) {
      if (elt && data.selectedElt && elt[CrudSrv.eltKey] === data.selectedElt[CrudSrv.eltKey]) {
        data.selectedElt = null;
      } else {
        data.selectedElt = elt;
      }
      return data.form = null;
    };
    _ctrlCreate = function(data) {
      return data.form = angular.copy(data.defaultFormElt);
    };
    _ctrlEdit = function(elt, data) {
      return data.form = angular.copy(elt);
    };
    _ctrlAddElt = function(obj, attr, _elt) {
      var elt;
      if (obj && typeof obj === 'object') {
        if (!Array.isArray(obj[attr])) {
          obj[attr] = [];
        }
        elt = _elt ? angular.copy(_elt) : {};
        return obj[attr].push(elt);
      } else {
        return $log.warn('Unable to addElt to', obj);
      }
    };
    _ctrlRemoveElt = function(arr, index) {
      if (Array.isArray(arr) && index < arr.length) {
        return arr.splice(index, 1);
      } else {
        return $log.warn('Unable to removeElt <' + index + '> from', arr);
      }
    };
    _ctrlCancelEdit = function(data) {
      return data.form = null;
    };
    _ctrlSave = function(_elt, CrudSrv, data) {
      var elt;
      data.status.saving = true;
      elt = _elt ? _elt : data.form;
      return CrudSrv.save(elt).then((function(elt) {
        CollectionUtils.upsertEltBy(data.elts, elt, CrudSrv.eltKey);
        if (data.currentSort) {
          Utils.sort(data.elts, data.currentSort);
        }
        data.selectedElt = elt;
        data.form = null;
        data.status.loading = false;
        return data.status.saving = false;
      }), function(error) {
        $log.info('error', error);
        data.status.saving = false;
        return data.status.error = err;
      });
    };
    _ctrlRemove = function(elt, CrudSrv, data) {
      if (elt && elt[CrudSrv.eltKey] && $window.confirm('Supprimer ?')) {
        data.status.removing = true;
        return CrudSrv.remove(elt).then((function() {
          CollectionUtils.removeEltBy(data.elts, elt, CrudSrv.eltKey);
          data.selectedElt = null;
          data.form = null;
          data.status.loading = false;
          return data.status.removing = false;
        }), function(error) {
          $log.info('error', error);
          data.status.removing = false;
          return data.status.error = error;
        });
      } else {
        return $q.when();
      }
    };
    _ctrlEltRestUrl = function(_elt, CrudSrv) {
      if (_elt && _elt[CrudSrv.eltKey]) {
        return CrudSrv.getUrl(_elt[CrudSrv.eltKey]);
      } else {
        return CrudSrv.getUrl();
      }
    };
    return service;
  });

}).call(this);

//# sourceMappingURL=crud-rest-utils.js.map
